MicroComp Development Notes

Registers:
a	accumulator
b	b ALU input and low byte of address register stack.
c	high byte of address register stack.
f	flag regsiter.

Note: ir is a transparent latch.

add		1	a + b -> a
	prog[pc] -> ir; pc++; a + b -> a; update flags

sub		1	a - b -> a
	prog[pc] -> ir; pc++; a - b -> a; update flags

and		1	a & b -> a
	prog[pc] -> ir; pc++; a & b -> a; update flags

or		1	a | b -> a
	prog[pc] -> ir; pc++; a | b -> a; update flags

xor		1	a ^ b -> a
	prog[pc] -> ir; pc++; a ^ b -> a; update flags

swf		1	a -> f; f -> a					Requires a direct bus from a to f.
	prog[pc] -> ir; pc++; a -> f; f -> a

shr		1	a >> b -> a
	prog[pc] -> ir; pc++; a >> b -> a; update flags

ldi		2	prog[pc] -> a
	prog[pc] -> ir; pc++
	prog[pc] -> a; pc++
ldi		2	prog[pc] -> b
	prog[pc] -> ir; pc++
	prog[pc] -> b; pc++

ldp		2	prog[b c] -> a
	prog[pc] -> ir; pc++
	prog[b c] -> a
ldp		2	prog[b c] -> b
	prog[pc] -> ir; pc++
	prog[b c] -> b

ldm		1	mem[b c] -> a
	prog[pc] -> ir; pc++; mem[b c] -> a
ldm		1	mem[b c] -> b
	prog[pc] -> ir; pc++; mem[b c] -> b

stp		2	a -> prog[b c]
	prog[pc] -> ir; pc++
	a -> prog[b c]

stm		1	a -> mem[b c]
	prog[pc] -> ir; pc++; a -> mem[b c]

brp		2	b c -> pc
	prog[pc] -> ir; ((prog[pc][2] ~^ flag[prog[pc][1:0]]) ? b c : pc + 1) -> pc

psh		1	b -> c
	prog[pc] -> ir; pc++; b -> c

nop		1
	prog[pc] -> ir; pc++;
	
External signals:
	clk
	!reset
	d[7:0]
	a[15:0]
	wr
	rd
	rco
	
Microcode signals:
0	!wrp		Program memory write
1	!rdp		Program memory read
2	!aoe		Accumulator output enable
3	!ashoe		Accumulator shift ouput enable
4	fsors		Flag source
5	flck		Flag clock
6	!aluoe		ALU output enable
7	aclk		Accumulator clock

8	sel0		ALU function select 0
9	sel1		ALU function select 1
a	sel2		ALU function select 2
b	bclk		b clock
c	!boe		b output enable
d	!foe		Flag register output enable
e	!jmp		Jump
f	!pcoe		Program counter output enable

10	dtoe		Data bus transciver output enable		
11	ddir		Data bus transciver direction
12	pcck		Program counter clock
13	cclk		c register clock
14	!bcoe		Place b and c onto the address bus
15	!wrd		Data memory write
16	!rdd		Data memory read
17	!upcrst		Microprogram counter reset

18	ick			Instruction register clock - Generated by a 4-input invert-and (nor) gate

Chips:
1	74574
2	74574
3	74257
4	74257
5	74381
6	74381
7	74574
8	74182
9	7486
10	74244
11	74244
12	74251
13	74244
14	74244
15	74244
16	74163/74161
17	74373
18	7432
19	74133
20	74280
21	2704
22	2704
23	2704
24	74574
25	74163/74161
26	74163/74161
27	74163/74161
28	74163/74161
29	74244
30	74244
31	74244
32	74244
33	74245
34	74260
35	7408

36	27256
37	51256
38	51256
39	74244
40	74574

//2764	0->3
27256	0->3	3	c
7432	1/4		1	ls
7486	2/4		1	s
74133	1		1	als
74161	1->2	1	as
74163	3->5	3	als,ls
74182	1		-	
74244	7		7	ls,f,act,als
74245	2		2	ls
74251	1		
74257	2		2	als,s
74381	2		2	ls
74574	4		4	hct,act
74280	1		1	s,ls,f
74373	1		1	ls

counters		5/32	16%
registers		5/32	16%
multiplexers	3/32	9%
3-state			9/32	28%
arithmetic		5/32	16%
glue logic		5/32	16%

Hardware design for processor finished on 12/16/2017
Hardware design revised on 12/22/2017 - Added !foe.

Important instructions:
	LDI
	PSH
	ADD
	SUB
	XOR
	OR
	AND
	CLR
	STM
	LDM
	STP
	LDP
	BR.
	NOP
	SHR

Tests:
ALU
Flags
A
B
C
PC
CU
ROM
RAM
Input
Output

Macro types:

Letter: address of a memory location.
Number: a 8-bit constant.

Macros:
%lda #
*ldi a #
*mov b a
nop
*jmp ####
*not a
*neg a
*inc a
*dec a
*addi a #
*subi a #
*andi a #
*ori a #
*xori a #
%stf
%ldf
*xnori a #
*cmpi a #
*test a
*ijmp [a, a+1, a+2, a+3]
*add a b
*sub a b
*cmp a b
*and a b
*or a b
*xor a b
*xnor a b
*ld b a
*st b a
*imov a b

*Memory-memory operations (designed for high-level programming)
%Memory-register operations (designed for mid-level programming)

lda ##
	LDI HIGH[##]
	PSH
	LDI LOW[##]

ldi a #
	LDI # A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	STM A

mov b a
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI HIGH[b] B
	PSH
	LDI LOW[a] B
	STM A

nop
	NOP

jmp ##
	LDI HIGH[##] B
	PSH
	LDI LOW[##] B
	MOV A
	SUB A
	BR.Z

not a
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI #FF B
	XOR A
	LDI LOW[a] B
	STM A

neg a
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	SUB A
	LDI LOW[a] B
	STM A

inc a
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI 1 A
	ADD
	LDI LOW[a] B
	STM A

dec a
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI 1 A
	SUB
	LDI LOW[a] B
	STM A

addi a #
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # A
	ADD A
	LDI LOW[a] B
	STM A

subi a #
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # A
	SUB A
	LDI LOW[a] B
	STM A

andi a #
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # A
	AND A
	LDI LOW[a] B
	STM A

ori a #
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # A
	OR A
	LDI LOW[a] B
	STM A

xori a #
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # A
	XOR A
	LDI LOW[a] B
	STM A

stf f
	LDI HIGH[f] B
	PSH
	LDI LOW[f] B
	SWF
	STM A

ldf f
	LDI HIGH[f] B
	PSH
	LDI LOW[f] B
	LDM A
	SWF

xnori a #
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # B
	XOR A
	LDI #FF B
	XOR A
	LDI LOW[a] B
	STM A

cmpi a # f
	LDI 0 A
	SWF
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM A
	LDI # B
	SUB B
	SWF
	LDI HIGH[f]
	PSH
	LDI LOW[f]
	STM A

test a f
	LDI 0 A
	SWF
	LDI HIGH[a]
	PSH
	LDI LOW[a]
	LDM A
	MOV B
	SUB A
	SWF
	LDI HIGH[f]
	PSH
	LDI LOW[f]
	STM A

ijmp [a+1 a] tempal
	LDI HIGH[a]
	PSH
	LDI LOW[a]
	LDM A
	LDI HIGH[tempal] B
	PSH
	LDI LOW[tempal] B
	STM A
	
	LDI 0 A
	SWF
	LDI LOW[a] A
	LDI 1 B
	ADD A
	LDI HIGH[a] A
	LDI 0 B
	ADD B
	PSH
	LDI 0 A
	SWF
	LDI LOW[a] A
	LDI 1 B
	ADD B
	LDM A
	SWF
	LDI HIGH[tempal]
	PSH
	LDI LOW[tempal]
	LDM A
	SWF
	MOV B
	PSH
	SWF
	MOV B
	SUB A
	BR.Z

add a b
	LDI 1 A
	SWF
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	ADD A
	LDI LOW[a] B
	STM A

sub a b
	LDI 0 A
	SWF
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	SUB A
	LDI LOW[a] B
	STM A

cmp a b f
	LDI 1 A
	SWF
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	SUB A
	SWF
	LDI HIGH[f]
	PSH
	LDI LOW[f]
	STM A

and a b
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	AND A
	LDI LOW[a] B
	STM A

or a b
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	OR A
	LDI LOW[a] B
	STM A

xor a b
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	XOR A
	LDI LOW[a] B
	STM A

xnor a b
	LDI HIGH[b] B
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[a] B
	PSH
	LDI LOW[a] B
	LDM B
	XOR A
	LDI #FF B
	XOR A
	LDI LOW[a] B
	STM A

ld a [b+1 b] tempbl tempbh
	LDI HIGH[b] B			;Move b to tempbl.
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[tempbl] B
	PSH
	LDI LOW[tempbl] B
	STM A
	
	LDI 0 A					;Move b+1 to tempbh.
	SWF
	LDI LOW[b] A
	LDI 1 B
	ADD B
	LDI HIGH[b] A
	LDI 0 B
	ADD B
	PSH
	LDI 0 A
	SWF
	LDI LOW[b] A
	LDI 1 B
	ADD B
	LDM A
	LDI HIGH[tempbh] B
	PSH
	LDI LOW[tempbh] B
	STM A
	
	LDI HIGH[tempbl] B		;Load mem[b+1 b] into A.
	PSH
	LDI LOW[tempbl] B
	LDM A
	LDI HIGH[tempbh] B
	PSH
	LDI LOW[tempbh] B
	LDM B
	PSH
	MOV B
	LDM A
	
	LDI HIGH[a]				;Store mem[b+1 b], which is stored in A, into a.
	PSH
	LDI LOW[a]
	STM A

st [a+1 a] b tempal tempah
	LDI HIGH[a] B			;Move a to tempal.
	PSH
	LDI LOW[a] B
	LDM A
	LDI HIGH[tempal] B
	PSH
	LDI LOW[tempal] B
	STM A
	
	LDI 0 A					;Move a+1 to tempah.
	SWF
	LDI LOW[a] A
	LDI 1 B
	ADD B
	LDI HIGH[a] A
	LDI 0 B
	ADD B
	PSH
	LDI 0 A
	SWF
	LDI LOW[a] A
	LDI 1 B
	ADD B
	LDM A
	LDI HIGH[tempah] B
	PSH
	LDI LOW[tempah] B
	STM A
	
	LDI HIGH[b] B			;Move b into the flag register.
	PSH
	LDI LOW[b] B
	LDM A
	SWF
	
	LDI HIGH[tempal] B		;Move b, which is in the flag register to mem[a+1 a].
	PSH
	LDI LOW[tempal] B
	LDM A
	LDI HIGH[tempah] B
	PSH
	LDI LOW[tempah] B
	LDM B
	PSH
	MOV B
	SWF
	STM A

imov [a+1 a] [b+1 b] tempbl tempbh tempal tempah
	LDI HIGH[b] B			;Move b to tempbl.
	PSH
	LDI LOW[b] B
	LDM A
	LDI HIGH[tempbl] B
	PSH
	LDI LOW[tempbl] B
	STM A
	
	LDI 0 A					;Move b+1 to tempbh.
	SWF
	LDI LOW[b] A
	LDI 1 B
	ADD B
	LDI HIGH[b] A
	LDI 0 B
	ADD B
	PSH
	LDI 0 A
	SWF
	LDI LOW[b] A
	LDI 1 B
	ADD B
	LDM A
	LDI HIGH[tempbh] B
	PSH
	LDI LOW[tempbh] B
	STM A
	
	LDI HIGH[a] B			;Move a to tempal.
	PSH
	LDI LOW[a] B
	LDM A
	LDI HIGH[tempal] B
	PSH
	LDI LOW[tempal] B
	STM A
	
	LDI 0 A					;Move a+1 to tempah.
	SWF
	LDI LOW[a] A
	LDI 1 B
	ADD B
	LDI HIGH[a] A
	LDI 0 B
	ADD B
	PSH
	LDI 0 A
	SWF
	LDI LOW[a] A
	LDI 1 B
	ADD B
	LDM A
	LDI HIGH[tempah] B
	PSH
	LDI LOW[tempah] B
	STM A
	
	LDI HIGH[tempbl] B		;Move mem[b+1 b] into the flag register.
	PSH
	LDI LOW[tempbl] B
	LDM A
	LDI HIGH[tempbh] B
	PSH
	LDI LOW[tempbh] B
	LDM B
	PSH
	MOV B
	LDM A
	SWF
	
	LDI HIGH[tempal] B		;Move mem[b+1 b], which is in the flag register to mem[a+1 a].
	PSH
	LDI LOW[tempal] B
	LDM A
	LDI HIGH[tempah] B
	PSH
	LDI LOW[tempah] B
	LDM B
	PSH
	MOV B
	SWF
	STM A

	
Final Instruction Set 1/16/18
	NOP
	LDI # A/B/C
	LDM A/B/C
	LDP A/B/C
	STM A
	STP A
	MOV A B/B A/A C/B C
	BR.
	SWF A
	SHR A/B
	ADD A/B/C
	SUB A/B/C
	AND A/B
	OR A/B
	XOR A/B

#00 NOP
	prog[pc++] -> ir
	
#01 LDI A
	prog[pc++] -> ir
	prog[pc++] -> A
	
#02 LDI B
	prog[pc++] -> ir
	prog[pc++] -> B
	
#03 LDI C
	prog[pc++] -> ir
	prog[pc++] -> C
	
#04 LDM A
	prog[pc++] -> ir
	mem[C B] -> A
	
#05 LDM B
	prog[pc++] -> ir
	mem[C B] -> B
	
#06 LDM C
	prog[pc++] -> ir
	mem[C B] -> C
	
#07 LDP A
	prog[pc++] -> ir
	prog[C B] -> A
	
#08 LDP B
	prog[pc++] -> ir
	prog[C B] -> B
	
#09 LDP C
	prog[pc++] -> ir
	prog[C B] -> C
	
#0A STM A
	prog[pc++] -> ir
	A -> mem[C B]
	
#0B STP A
	prog[pc++] -> ir
	A -> prog[C B]
	
#0C MOV A B
	prog[pc++] -> ir
	A -> B
	
#0D MOV B A
	prog[pc++] -> ir
	B -> A
	
#0E MOV A C
	prog[pc++] -> ir
	A -> C
	
#0F MOV B C
	prog[pc++] -> ir
	B -> C
	
#10 BR.cc
	prog[pc++] -> ir
	fr[cc[2:0]]^cc[3] ? pc + 1 : C B -> pc
	
#11 SWF
	prog[pc++] -> ir
	A -> F / F -> A
	
#12 SHR A
	prog[pc++] -> ir
	A >> 1 -> A
	
#13 SHR B
	prog[pc++] -> ir
	A >> 1 -> B
	
#14 ADD A
	prog[pc++] -> ir
	A + B + carry -> A
	
#15 ADD B
	prog[pc++] -> ir
	A + B + carry -> B
	
#16 ADD C
	prog[pc++] -> ir
	A + B + carry -> C
	
#17 SUB A
	prog[pc++] -> ir
	A - B -> A
	
#18 SUB B
	prog[pc++] -> ir
	B - A -> B
	
#19 SUB C
	prog[pc++] -> ir
	A - B -> C
	
#1A AND A
	prog[pc++] -> ir
	A & B -> A
	
#1B AND B
	prog[pc++] -> ir
	A & B -> B
	
#1C OR A
	prog[pc++] -> ir
	A | B -> A
	
#1D OR B
	prog[pc++] -> ir
	A | B -> B
	
#1E XOR A
	prog[pc++] -> ir
	A ^ B -> A
	
#1F XOR B
	prog[pc++] -> ir
	A ^ B -> B
	


Assembler kind of works.

Microcontroller will be connected to the I/O port.
Microcontroller will be connected to the address, WR, and data of the microcode RAMs.

More than one microcontroller is acceptable. Four AVRs controlled by one master may or may not be since they take up board space. That would also require a fancier VM and possibly more memory.
Time is not an object.


12 address
1 wr
24 data
8 in
8 out
1 reset
1 pcrst

55 IO
17 pins×3 AVRs

8'(out 8'port 8'data)
8'(in 8'port)

LPC1769 has 70 IO, but ~5 are not 5 V tolerant.
512 KiB is more than enough for a simple VM.

Next step: Cleanup VM memory. Get DL running on ARM.

LPC1769 dev board has 54 pins, but it still has a ton of memory.

REPL is running! And I can send small snippets to the MCU to configure registers instead of sending a single massive script!
`comptime` and `defmacro` allow for a massive library and tiny binaries. I 💙 comptime computing!

IR has an OC pin.
Μcode has registered outputs with OC.
Μcode ROM has OE and WE.
ΜPC does not have OE. This can be fixed with a '125 if I have one. (I probably have a ton)

Five new chips
Four swapped chips

defer wrp (Not connected because there is no program RAM)
defer coe (Not connected. Is there no C output buffer?)


Assembler can write to file.

Next step: Program Flash with the contents of "fibonacci.bin".

Bytes flashed manually.

Next step: Wire up '125. Wire up microcontroller.


MCU has full control over RAMs. The only problems that can occur are with interfacing with the rest of the computer. The µcode output '574s can be put into high Z. Pull-up resistors can be added if necessary. The IR can be put into high Z. The µPC cannot, but it will pass through a '125. The '125 and '374 OEs will be connected together.


24 µcode output
1 µcode oe
1 µcode we
1 µcode register oe
1 µcode address oe
1 clock
2 reset
-------------------
31 pins
-------------------
≤ 12 µcode address
-------------------
43 pins

There may be enough pins on the dual-inline pins alone.

'125 wired.

Next step: Wire pull-ups, or wire MCU.

Pull-ups wired.

Next step: Wire MCU.

Port 0 is data[23:0]
Port 2 is address[~12:0]

Not all pins are 5 V tolerant!

0.15     1 (TXD1) UART Tx
0.16     1 (RXD1) UART Rx
0.0:11  12 
0.17:18  2 
0.21:26  6 
0.27:28  2 pull up
1.0:1    2 
1.4      1 
1.8:10   3 
1.14:17  4 
1.30:31  2 
2.0:8    9 
2.10:13  4 
0.19:20  2 unpinned
1.18:29 12 unpinned
2.9      1 unpinned
3.25:26  2 unpinned
4.28:29  2 unpinned

0 22 
1 12 
2 11 
3  0 
4  0 
0  2 unpinned
1 12 unpinned
2  1 unpinned
3  2 unpinned
4  2 unpinned

45
19

6 IR & 4 µPC = 10 addr
24 - 3 = 21 data
31 total

All data and address wires connected. Four control pins remaining.

Everything important connected.

Computer & MCU draw 5V@0.76A.

Shutdown
    Unplug all USB from PC.
    Power off STK500.
    Power off MicroComp.

Extra pins: reset state, reset PC
Need two extra pins. Round up to three.


Bit 5 of the microcode address is low. I think it might be floating low.

It turns out some wires were connected improperly. I don't think that was the original problem, but putting the wires in the right place finished the fix. I believe the microcode SRAMs are programmed correctly now. The microcode bits should correspond to the correct signals too.
